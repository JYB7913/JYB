<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    //JS中有哪些数据类型
    //基本数据：Number String Boolean Null Underfined
    //引用数据类型：对象数据类型 函数数据类型

    //什么是闭包？闭包作用？在工作中是如何应用的?
    //闭包本质还是函数，只不过这个函数绑定了上下文环境（函数内部引用的所有变量）。

    //管理私有变量和私有方法，将对变量（状态）的变化封装在安全的环境中

    //闭包的一个通常的用法是为一个在某一函数执行前先执行的函数提供参数。
    // 逻辑连续，当闭包作为另一个函数调用的参数时，避免你脱离当前逻辑而单独编写额外逻辑。


    //JS实现继承的几种方式?
    //1.原型链继承:将父类的实例作为子类的原型
    //2.构造继承:把父类当作普通函数在子类里执行 将里面的this修改为子类中的实例
    //3.组合式继承：原型链继承+借用构造函数继承
    //4.原型式继承:创建一个新对象 将将父类原型作为参数传递作为这个对象的原型 Object.create()
    //5.继生组合继承:借用构造函数+原型式继承
    //6.对象冒充继承：在子类构造函数中 生成一个父类的实例 把父类的实例当作一个普通对象 进行遍历 把父类实例的私有和公有属性遍历出来  添加给子类实例的私有属和方法
    //中间类继承：IE 屏蔽了 通过__proto__改变指向

    //创建对象的三种方式?
    //1.通过”字面量“方式创建。var obj={}
    //2.通过”构造函数“方式创建 var obj = new 函数名();
    //通过object方式创建。var obj = new Object();

    //new Person()时发生了什么?
    //Person p = new Person();
    //A：将Person.class文件加载到内存中。
    //B：在堆内存中创建一个对象Person。
    //C：把Person中的属性进行默认初始化。
    //D：把Person中的属性进行显示初始化。
    //E：调用构造代码块(如果没有，不执行这个操作)。
    //F：调用构造函数进行初始化。
    //G：在栈内存中声明Person类型的变量P。
    //H：把堆内存的地址(引用)赋给了栈内存中P。

    //什么是深拷贝和浅拷贝？自己不用JSON.parse实现一个深拷贝的方法
    //深拷贝 指的是对象中，里面存放的对象和以前的对象毫无关系，但是长的一样.
    //浅拷贝里面存放的内容和以前的是同一个地址
    var obj={name:'abing',age:18};
    let newObj={...obj};

    //手工模拟完整的bind方法
    Function.prototype._bind=function (that) {
      var fn=this;
      var params=[].slice.call(arguments,1);
      return function () {
          var arr=params.length?params:arguments;
          fn.apply(that,arr)
      }
    }

    //什么是节流和防抖？
    //函数节流是指一定时间内js方法只跑一次。
    //函数防抖是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。

    //上拉刷新和下拉加载的实现原理？

    //写一个验证邮件的正则表达式
    let reg=/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(.[a-zA-Z0-9_-])+/;

    //事件绑定和普通事件的区别（可以举例说明）
    //普通添加事件的方法：
    var btn = document.getElementById("hello");
    btn.onclick = function(){
        alert(1);
    };
    btn.onclick = function(){
        alert(2);
    };
    //执行上面的代码只会alert 2
    //事件绑定方式添加事件：
    var btn = document.getElementById("hello");
    btn.addEventListener("click",function(){
        alert(1);
    },false);
    btn.addEventListener("click",function(){
        alert(2);
    },false);
    //执行上面的代码会先alert 1 再 alert 2
    //通添加事件的方法不支持添加多个事件，最下面的事件会覆盖上面的，而事件绑定（addEventListener）方式添加事件可以添加多个。


    //javascript 模版引擎用过哪些？实现原理是什么？
    //ejs模板 <%=   %>
    //es6模板字符串  ``
    //实现原理：正则匹配 然后替换
    //合并两个对象
    let obj1={name:'abing'};
    let obj2={age:18};
    var obj3=Object.assign(obj1,obj2);

    //es7语法
    let obj4={...obj1,...obj2};

    //动态向一个div中插入1000个div标签，如何实现？（考性能）
    //1.字符串拼接 ：只引发一次回流
    var str='';
    for(var i=0;i<1000;i++){
        str+='<div></div>'
    }
    div.innerHTML+=str;
    //2.动态创建
    var frg=document.createDocumentFragment();//创建文档碎片
    for(var i=0;i<1000;i++){
        var div=document.createElement('div');
        frg.appendChild(div);
    }
    div.appendChild(frg);//将文档碎片里的内容一次性的添加到外层div中
    frg=null;//将文档碎片里的内容清空


    //html5新特性
    //用于绘画的 canvas 元素
    //用于媒介回放的 video 和 audio 元素
    //对本地离线存储的更好的支持Local Storage
    //新的特殊内容元素，比如 article、footer、header、nav、section
    //新的表单控件，比如 calendar、date、time、email、url、search


    //严格模式和非严格模式的区别 "use strict"
    //1.在严格模式中禁止使用width语句
    //2.在严格模式中，所有的变量都要先声明；（在非严格模式中中，这种隐式声明的全局变量的方法是给全局对象新添加一个新属性）；
    //3.在严格模式中，调用的函数中的一个this值是undefined（在非中，调用的函数中的this总数全局对象）；
    //4.在严格模式中，当通过call（）或apply（）来调用函数时，其中的this值就是通过call（）或者apply（）传入的第一个参数；（在非中，null和undefined被全局对象和转换为对象的非对象值所替代）；
    //5.在严格模式中，给只读属性赋值和给不可扩展的对象创建新成员都将抛出一个类型错误异常；（在非中，这些操作只是简单地操作失败，不会报错）；
    //6.在严格模式中，传入eval（）的代码不能在调用程序所在的上下文中声明变量或定义函数；（在非中，可以这样做，相反，变量和函数的定义是在eval（）创建的新作用域中，这个作用域在eval（）返回时就弃用了）


    //对于js中浮点数计算会丢失精度的问题，你有什么解决思路？
</script>
</body>
</html>